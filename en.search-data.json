{"/docs/anki/anki/":{"data":{"":"","setup#Setup":"","コマンド#コマンド":"Setup Anki まずは、Ankiをこちらからダウンロードしてインストールします。\nAnki Connect OrgファイルとAnkiを連携するためには、Ankiアプリに Anki Connectというプラグインをインストールする必要があります。 プラグインのインストール後、Ankiアプリを再起動してください。\nEmacs init.el に以下のコードを追加し、 anki-editor の設定を行いました。\n(leaf anki-editor :doc \"Minor mode for working with Anki decks and notes.\" :url \"https://github.com/louietan/anki-editor\" :ensure t :bind ((:anki-editor-mode-map (\"C-c a\" . anki-editor/body))) :pretty-hydra ((:title \"Anki Editor\" :color blue :quit-key \"q\" :foreign-keys warn :separator \"╌\") (\"Main\" ((\"p\" anki-editor-push-notes \"push notes\") (\"n\" anki-editor-push-new-notes \"push new notes\") (\"r\" anki-editor-retry-failed-notes \"retry failed notes\")) \"Editing\" ((\"i\" anki-editor-insert-default-note \"insert default\") (\"I\" anki-editor-insert-note \"insert note\") (\"d\" anki-editor-delete-notes \"delete note\") (\"c\" anki-editor-cloze-dwim \"cloze region or word\")) \"Export\" ((\"e\" anki-editor-export-subtree-to-html \"export subtree to HTML\") (\"h\" anki-editor-convert-region-to-html \"convert region to HTML\")) \"Other\" ((\"a\" anki-editor-api-check \"API check\") (\"s\" anki-editor-sync-collections \"sync collections\") (\"b\" anki-editor-gui-browse \"browse in GUI\") (\"g\" anki-editor-gui-add-cards \"add cards in GUI\"))))) READMEに載ってるコマンドをChatGPTに貼り付けて、pretty-hydra化した。\nコマンド anki-editor-insert-note ノート作成用コマンドです。以下の手順でノートが作成されます。\nデッキの選択 ノートタイプの選択 ノートの見出し(Note Heading)の入力 上記を入力すると、Anki用の PROPERTIES が付与されたOrgエントリが挿入されます。 挿入時点ではAnki側には送信されないため、送信は別途 anki-editor-push-notes コマンドで行います。\nなお、デッキはOrgファイルのプロパティや、親のサブツリーに設定がある場合は継承されるので、 コマンド実行時に入力する必要はありません。 また、anki-editorは、READMEに記載されているようにBack/Front用のサブツリーを省略した簡易的な書き方もサポートしています。 この形式を使用したい場合は、Note Headingを空欄にしておくと自動でサブツリーが作成されません。\nanki-editor-insert-default-note このノート作成コマンドは、Orgファイルのプロパティや親のサブツリーで設定した ANKI_DEFAULT_NOTE_TYPE を自動で読み込み、 ノートタイプを決定します。 私の運用では、1つのOrgファイルにつき1つのデッキとノートタイプのみを使用しているため、 Orgファイルのプロパティに ANKI_DECK と ANKI_DEFAULT_NOTE_TYPE を設定し、 このコマンドを使ってノートを追加するようにしています。\nanki-editor-push-notes 作成したノートをAnkiアプリに送信するためのコマンドです。 Ankiアプリが起動中で、かつAnki Connect設定済みである必要があります。\n送信後、エントリにANKI_NOTE_IDが付与され、次回以降の更新が可能になります。\n:PROPERTIES: :ANKI_NOTE_TYPE: Basic :ANKI_DECK: English :ANKI_NOTE_ID: 1729834505855 :END: anki-editor-push-new-notes まだAnkiに送信していないノートを送信します。\nanki-editor-cloze-dwim 択したリージョンまたはカーソル下の単語をAnkiの穴埋め問題形式に変換します。 穴埋め問題についてはこちらが分かりやすいです。\nanki-editor-gui-browse カーソル位置のノートをAnkiアプリで確認できます。"},"title":"Anki"},"/docs/emacs/%E3%81%8A%E6%89%8B%E8%BB%BDbookmark/":{"data":{"":"","参考#参考":"とりあえず consult-bookmark を既存のbookmark-jumpコマンド(C-x r b)と置き換えておけばOK。 consult-bookmark からブックマークの一覧表示も登録もどちらも出来る。\nまた、 consult-buffer で m SPC を入力してもブックマーク一覧になる。\n登録したブックマークを編集したいときは、 M-x edit-bookmarks で Bookmark List バッファが表示される。 バッファ内で ? を入力すると操作コマンドが確認できる。以下、よく使いそうなやつ。\nコマンド 説明 RET ブックマークに移動。 o リストを残しつつ別ウィンドウでブックマークに移動。 r ブックマークの名前を変更 d 削除マークを付ける。 x 削除マークされたブックマークを削除。 参考 Emacs: Bookmarks"},"title":"お手軽Bookmark"},"/docs/emacs/20241020210719-tab_bar_mode/":{"data":{"":"","tab-bar-mode#tab-bar-mode":"tab-bar-mode ずっとバッファをtabに表示するものと思って使ってこなかった (それは多分 tab-line-mode)。 tab-bar-mode はウィンドウ構成を1タブで管理する。便利。\n使いそうなコマンド:\nC-x t 2: 新規タブ作成 C-x t 0: 現在タブ削除 C-x t o: タブ移動 C-x t RET: タブ選択 tab-bar-history-mode を有効にすると、タブ一覧の左に\u003c \u003eが表示されるようになる。 これをポチポチすると、そのタブのウィンドウ構成を遡ることができる。 tab-bar-historyのコマンドもあるけど滅多に使わなそうなので、当面マウス操作で良いか。\ntab-bar-mode を使うと org-agenda-window-setup で other-tab のオプションが使えるようになる\n(setq org-agenda-window-setup 'other-tab) org-agendaを開くと、自動で新規タブが作られ、そのタブでアジェンダが表示される。 アジェンダを閉じるとタブも閉じられる。 既存のウィンドウ構成を崩さずにフレームを目一杯使ってアジェンダを表示できて嬉しい\n参考 tab-bar-modeを探検する "},"title":"tab-bar-mode"},"/docs/emacs/20241021104652-smartparens/":{"data":{"":"","smartparens#smartparens":"smartparens s-c にhydraを用意した。\n(leaf *hydra-cursor :doc \"Move cursor effectively\" :bind (\"s-c\" . *hydra-cursor/body) :after smartparens :pretty-hydra ((:title \"➤ Smart Cursor\" :color blue :quit-key \"q\" :foreign-keys warn :separator \"╌\") (\"Sexp\" ((\"a\" sp-beginning-of-sexp \"Begin\" :exit nil) (\"e\" sp-end-of-sexp \"End\" :exit nil) (\"d\" sp-down-sexp \"Down\" :exit nil) (\"u\" sp-up-sexp \"Up\" :exit nil) (\"D\" sp-backward-down-sexp \"Down backward\" :exit nil) (\"U\" sp-backward-up-sexp \"Up backward\" :exit nil) (\"n\" sp-next-sexp \"Next\" :exit nil) (\"p\" sp-previous-sexp \"Previous\" :exit nil) (\"F\" sp-forward-sexp \"Forward\" :exit nil) (\"B\" sp-backward-sexp \"Backward\" :exit nil)) \"Symbol\" ((\"f\" sp-forward-symbol \"Forward\" :exit nil) (\"b\" sp-backward-symbol \"Backward\" :exit nil)) \"Wrap\" ((\"(\" wrap-with-parens \"() parens\" :exit nil) (\"[\" wrap-with-brackets \"[] brackets\" :exit nil) (\"{\" wrap-with-braces \"{} braces\" :exit nil) (\"'\" wrap-with-single-quotes \"'' single quotes\" :exit nil) (\"\\\"\" wrap-with-double-quotes \"\\\"\\\" double quotes\" :exit nil)) \"Unwrap\" ((\",\" sp-backward-unwrap-sexp \"Backward\" :exit nil) (\"k\" sp-kill-sexp \"Kill\" :exit nil) (\".\" sp-forward-unwrap-sexp \"Forward\" :exit nil)) \"Expand\" ((\"+\" sp-forward-slurp-sexp \"Expand\" :exit nil) (\"-\" sp-forward-barf-sexp \"Shrink\" :exit nil))))) 正直、カーソルの移動系はnativeとの違いが分からないのが多かった。 以下は見たことがない動きなので使えるかも。\nsp-next-sexp ( C-M-n にもバインド) sp-previous-sexp ( =C-M-p にもバインド) wrap-xxxはこちらの defcustom を使わせて頂いた。 C-SPC で選択した範囲を囲うのと併せて、使う機会は多そう。\n参考 Emacsの括弧機能を超絶強化するsmartparensとrainbow-delimiters "},"title":"smartparens"},"/docs/emacs/20241021144801-lsp_bridge/":{"data":{"":"","lsp-breidge-refのカスタマイズ#lsp-breidge-refのカスタマイズ":"lsp-breidge-refのカスタマイズ lsp-bridgeは C-c C-r で参照一覧をlsp-briedge-ref ウィンドウで表示するが、 一覧を閉じるタイミングで、これまで参照から開いてたたバッファも全て消えてしまう。\nこれは、 lsp-bridge-ref-kill-temp-buffer-p と lsp-bridge-ref-open-file-in-request-window の両方を nilにすることで解決する。 以下でlsp-bridge-refに関するcustomize変数をまとめる。\n設定名 初期値 説明 lsp-bridge-ref-delete-other-windows t refウィンドウを開くタイミングで、refを開始したウィンドウ以外のウィンドウを閉じるか lsp-bridge-ref-open-file-in-request-window nil refで参照先を移動する際に、refを開始したウィンドウをそのまま使用するか lsp-bridge-ref-kill-temp-buffer-p t refウィンドウから開いたバッファを保持せずに閉じるか lsp-bridge-ref-open-file-in-request-window をtにすると lsp-bridge-ref-kill-temp-buffer-p が無効になる気がする"},"title":"lsp-bridge"},"/docs/emacs/20241022120540-gpg_gnupg/":{"data":{"":"","秘匿情報をgpgファイルから取得する#秘匿情報をgpgファイルから取得する":"秘匿情報をgpgファイルから取得する init.el に直接書きたくない秘匿情報の扱いに困ることがたまにあって、 gpgファイルについて調べた。よく分かってないこともあるが、以下で自分に必要な最低限のことはできる。 (※対象環境はMacOS)\nインストール pgp と pinentry-mac をインストール\nbrew install gnupg brew install pinentry-mac pinentry-macはパスフレーズを入力するためのUIで、 PGPファイルをパスフレーズで暗号化するときに使用する。\nインストールしたら、 .bashrc で以下の環境変数を設定し、\nexport GPG_TTY=$(tty) さらに、pgp-agent.confでpinentry-programを指定する。\necho \"pinentry-program /opt/homebrew/bin/pinentry-mac\" \u003e\u003e ~/.gnupg/gpg-agent.conf gpgをインストールしただけだと、パスフレーズ入力のタイミングでエラーになるので注意\nError while encrypting with “/opt/homebrew/bin/gpg”:\ngpg: problem with the agent: Inappropriate ioctl for device gpg: error creating passphrase: Operation cancelled gpg: symmetric encryption of ‘[stdin]’ failed: Operation cancelled\nPGPファイルの作成 ~/.authinfo.gpg に以下の形式でgpgファイルを作成する。\nmachine gcal-client-id login your-client-id password 123456789-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com machine gcal-client-secret login your-client-secret password ABCDEF-GhIjKlMnOpQrStUvWxYz machine はサービスや識別子を指定する。 elisp から :host で指定する login は本来ユーザー名らしいけど、今回は使わない password の後に実際の値（クライアントIDやクライアントシークレット）を記述する。 elisp elispからは auth-source パッケージの auth-source-pick-first-password を使って設定した password の値を取得できる\n(setq auth-sources '(\"~/.authinfo.gpg\")) (setq gcal-client-id (auth-source-pick-first-password :host \"gcal-client-id\")) (setq gcal-client-secret (auth-source-pick-first-password :host \"gcal-client-secret\")) あとで読みたい Keeping Secrets in Emacs with GnuPG and Auth Sources "},"title":"gpg (GnuPG)"},"/docs/emacs/copilot/":{"data":{"":" s-p でcopilotモード起動 Tab で補完の選択 C-c Tab で次の補完 とした。copilot-chatも導入して、特に問題なく動いているが、現時点で使用する場面がはっきりしていない。\n(leaf copilot :el-get (copilot :type github :pkgname \"zerolfx/copilot.el\") :bind (\"s-p\" . copilot-mode) :config (leaf editorconfig :ensure t) (leaf s :ensure t) (leaf dash :ensure t) (defun my/copilot-tab () (interactive) (or (copilot-accept-completion) (indent-for-tab-command))) (with-eval-after-load 'copilot (define-key copilot-mode-map (kbd \"\u003ctab\u003e\") #'my/copilot-tab) (define-key copilot-mode-map (kbd \"C-c \u003ctab\u003e\") #'copilot-next-completion))) (leaf copilot-chat :el-get (copilot-chat :type github :pkgname \"chep/copilot-chat.el\") :after (request shell-maker) :custom (copilot-chat-frontend 'shell-maker) :config (require 'copilot-chat-shell-maker) (push '(shell-maker . copilot-chat-shell-maker-init) copilot-chat-frontend-list) (copilot-chat-shell-maker-init)) "},"title":"Copilot"},"/docs/emacs/fifteen-ways-to-use-embark-%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0/":{"data":{"":"","1-dot-open-any-buffer-by-splitting-any-window#1. Open any buffer by splitting any window":"","10-dot-export-emacs-package-candidates-to-a-package-menu#10. Export Emacs package candidates to a package menu":"","11-dot-collect-imenu-candidates-in-an-imenu-list#11. Collect imenu candidates in an “imenu-list”":"","12-dot-export-file-candidates-to-a-dired-buffer#12. Export file candidates to a dired-buffer":"","13-dot-export-buffer-candidates-to-ibuffer#13. Export buffer candidates to ibuffer":"","14-dot-export-variable-candidates-to-a-customize-buffer#14. Export variable candidates to a customize buffer":"https://karthinks.com/software/fifteen-ways-to-use-embark/\n備忘のためのメモ。\n1. Open any buffer by splitting any window いきなりだが個人的に使わなそうなので詳細は割愛。 内容としては、ファイルを開く際にどのウィンドウを使うか、またはどのウィンドウをスプリットして開くかを any windowを使って指定するというもの。先にウィンドウを作ってそこで開く方が早くないか?と思ってしまった。 ただ、実際に運用してみて印象が変わるかもしれないので、また機会があったら試してみたい。\n2. Copy a file to a remote location when finding a file Find file などでファイルを絞り込む embark-act -\u003e c でコピー先を指定してコピー embark-act の際にプリフィックス(C-u) を付けると、find-fileから抜けずに続行できる\n3. Insert a minibuffer candidate into the buffer Find file などでファイルを絞り込む embark-act -\u003e i で現在のバッファにファイル名を挿入する I だと相対パスか、もしくはバッファのコンテンツを挿入できる場合もあるらしいが、試したところバッファの挿入になることは未だない。\n4. Run a shell command on a minibuffer candidate file without losing your session Find file などでファイルを絞り込む embark-act -\u003e \u0026 で async-shell-command 。選択したファイル名が挿入された状態で実行できる。 動画では file コマンドを実行していた。たしかに、ファイルを指定してコマンドを実行したい場面は割とよくあるかも。\n5. Open a file as root without losing your session 自PC内でrootを取ってファイル操作したい場面はあまり無いので割愛。\n6. Upload a region of text to 0x0 0x0.st というファイル共有サービスがあって、そこにリージョンの内容をアップロードするという内容。 便利だが、自分の場合他人に何かを共有する場面はほとんどが業務に関することなので、利用することは無さそう。\n7. Visit a package’s URL from the minibuffer Describe package (C-h P) embark-act -\u003e u で embark-browse-package-url 。 パッケージのURLがブラウザが開かれる。 8. Set a variable from anywhere it appears in a buffer elispのバッファで、変数にカーソルを合わせて embark-act = で set-variable できる 9. Add a keybinding for a command name from anywhere it appears バッファ内のコマンド名から global-set-key できるらしい。あまり使う機会は無さそう。\n10. Export Emacs package candidates to a package menu embark-export は日頃から使ってるので割愛。\n11. Collect imenu candidates in an “imenu-list” imenu を embark-export したいモチベーションが分からなかったが、 imenu を普段使ってないから分からないだけかもしれない。 便利そうなので積極的に使っていきたい。 取り急ぎ consult-imenuを M-g i にセットした。\n12. Export file candidates to a dired-buffer Find file などでファイルを絞り込む embark-export すると絞り込んだファイル一覧でdiredバッファが作られる。 diredになるの知らなかった。\n13. Export buffer candidates to ibuffer バッファ一覧で embark-export すると ibufferになる。\n14. Export variable candidates to a customize buffer describe-variable の変数一覧で embark-export するとcustomize bufferになる。","2-dot-copy-a-file-to-a-remote-location-when-finding-a-file#2. Copy a file to a remote location when finding a file":"","3-dot-insert-a-minibuffer-candidate-into-the-buffer#3. Insert a minibuffer candidate into the buffer":"","4-dot-run-a-shell-command-on-a-minibuffer-candidate-file-without-losing-your-session#4. Run a shell command on a minibuffer candidate file without losing your session":"","5-dot-open-a-file-as-root-without-losing-your-session#5. Open a file as root without losing your session":"","6-dot-upload-a-region-of-text-to-0x0#6. Upload a region of text to 0x0":"","7-dot-visit-a-package-s-url-from-the-minibuffer#7. Visit a package’s URL from the minibuffer":"","8-dot-set-a-variable-from-anywhere-it-appears-in-a-buffer#8. Set a variable from anywhere it appears in a buffer":"","9-dot-add-a-keybinding-for-a-command-name-from-anywhere-it-appears#9. Add a keybinding for a command name from anywhere it appears":""},"title":"Fifteen ways to use Embark を読んだ"},"/docs/emacs/lsp-dart/":{"data":{"":"久し振りにFlutterプロジェクトを開いたら、動かなくなってて困った。 前回からEmacsの設定を大幅な見直しがあったので、それが要因だと思うけど、結局根本的な原因はよく分からず…\n以前はlsp-dartを入れるだけで大体動いたと記憶してるが、今回はシンタックスハイライトが効かなかったり、LSPが起動しなくなったり嵌ってしまった。\n(leaf dart-mode :ensure t :init (require 'tree-sitter) (require 'treesit) (add-hook 'dart-mode-hook #'tree-sitter-hl-mode) :mode ((\"\\\\.dart\\\\'\" . dart-mode))) (leaf lsp-dart :ensure t :config (defun wal/find-dart-flutter-sdk-dir () \"Find the Dart Flutter SDK directory.\" (when-let* ((flutter-bin (executable-find \"flutter\")) (sdk-dir (string-trim (shell-command-to-string \"flutter sdk-path\")))) sdk-dir)) (setq lsp-dart-test-tree-on-run nil) (when (string= system-type \"gnu/linux\") (setq lsp-dart-flutter-sdk-dir (wal/find-dart-flutter-sdk-dir))) (when (string= system-type \"darwin\") (setq lsp-dart-flutter-sdk-dir \"~/flutter\")) (when (string= system-type \"windows-nt\") (setq lsp-dart-flutter-sdk-dir \"C:/Users/wtnbjn/scoop/apps/flutter/current\")) :custom (lsp-dart-test-tree-on-run . nil) :hook (dart-mode-hook . lsp)) 以下のとおり、 dart-mode でtree-sitter-hl-modeをフックするようにした。\n:init (require 'tree-sitter) (require 'treesit) (add-hook 'dart-mode-hook #'tree-sitter-hl-mode) :mode ((\"\\\\.dart\\\\'\" . dart-mode))) こんなの前までやらなくてもハイライトされてたと思うんだけど、謎。\ndar-ts-mode を用意してくれてる方がいて、セットアップすると ts-mode になるのでハイライトされるが、 今度はlsp-dartでlspが起動しなくなってしまう。 多分、lsp-dartがまだdart-mode前提になってる。"},"title":"lsp-dart"},"/docs/emacs/org%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A7%E6%95%B0%E5%BC%8F%E3%82%92%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AElatex%E8%A8%AD%E5%AE%9A/":{"data":{"":"","elisp#Elisp":"","インストール#インストール":"","参考#参考":"Emacsで数式をプレビューするためのLaTeX環境を構築した。\n“Emacs”, “LaTeX”、で検索するとLaTeXで執筆するための解説記事が出てくるが、 私はOrgモードで数式プレビューができれば十分なので、そのための最小限の設定をまとめた。\n対象環境: MacOS インストール GUIなしのMacTeXをインストールするために、以下のコマンドを実行。\nbrew install --cask mactex-no-gui Elisp AUCTeXをインストールし、以下の設定を追加した。\n(leaf auctex :ensure t :hook (TeX-mode-hook . LaTeX-math-mode) (TeX-mode-hook . auto-image-file-mode) :init (setq org-preview-latex-default-process 'dvipng) (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.5)) :config (leaf latex-math-preview :ensure t :after auctex :config (setq latex-math-preview-in-math-mode-p-func 'latex-math-preview-in-math-mode-p latex-math-preview-tex-to-png-for-preview '(platex dvipng) latex-math-preview-tex-to-png-for-save '(platex dvipng) latex-math-preview-tex-to-eps-for-save '(platex dvips-to-eps) latex-math-preview-beamer-to-png '(platex dvipdfmx gs-to-png))) (leaf company-math :ensure t :hook (TeX-mode-hook . company-math-mode-setup) :config (defun company-math-mode-setup () (require 'company-math) (setq-local company-backends (append '((company-math-symbols-latex company-latex-commands)) company-backends)))) ;; インラインプレビューの高速化 (add-hook 'TeX-mode-hook (lambda () (setq preview-image-type 'dvipng))) ;; インラインプレビューの文字化け回避 (add-hook 'TeX-mode-hook (lambda () (setq preview-default-option-list '(\"displaymath\" \"floats\" \"graphics\" \"textmath\" \"footnotes\"))))) この設定で、OrgファイルにLaTeX形式で数式を書いたら、 C-c C-x C-l でプレビューできるようになった。 デフォルトではプレビュー文字が小さかったため、以下の設定で文字サイズを大きくしている。\n(setq org-preview-latex-default-process 'dvipng) (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.5)) いきなりOrgファイルに直接LaTeXを書くのは難しいので、texlab というLaTeX用のLSPサーバを導入して .sty ファイルでLSPのサポートを受けながら書いたものをOrgモードに写している。\n:hook (go-ts-mode-hook . eglot-ensure) (LaTeX-mode-hook . eglot-ensure) :config (add-to-list 'eglot-server-programs '(LaTeX-mode . (\"texlab\")))) こちらを参考にして数式の書き方を覚えていきたい。\n参考 EmacsにおけるLaTeX執筆環境構築（１）AUCTeXの設定と使い方について 【見習いTeX使いのために】最初に覚えるコマンドまとめ "},"title":"Orgモードで数式をプレビューするためのLaTeX設定"},"/docs/emacs/org-download/":{"data":{"":"","コマンド#コマンド":"org-downloadの使い方について調べたのでメモ。 downloadという名前が若干ややこしく感じるが、ローカル画像をインサートする際の便利機能としても使える。\n動作環境 GNU Emacs 30.0.91 (build 1, aarch64-apple-darwin23.6.0, NS appkit-2487.70 Version 14.6.1 (Build 23G93)) of 2024-10-16\nドラッグ\u0026ドロップ まずドラッグ\u0026ドロップだが、私の環境では正常に動作しない。 Emacs29で本体に導入されたドラッグ\u0026ドロップ機能と競合してるのが原因のようだ。\nIntegration with emacs 29 and native drag and drop support #215 org-download-image-dir はorg-downloadでダウンロードした画像の保存先として指定されているが、 ドラッグ\u0026ドロップ時にはこの設定が使われず、カレントフォルダ内のdataフォルダに画像が保存されてしまう。 あと、これは私の環境の問題かもしれないが、挿入されるインライン画像のパスがずれてしまう。\nコマンド 以下のコマンドを使用することで、画像ファイルを保存し、インライン画像として挿入できる。 画像の保存先は org-download-image-dir で指定したフォルダになる。\norg-download-image このコマンドを実行すると、ミニバッファに入力したURLの画像がダウンロードされ、挿入される。\norg-download-clipboard クリップボードにコピーした画像を挿入する。 このコマンドを使う場合、MacOSでは pngpaste のインストールが必要となる。\nbrew install pngpaste org-download-yank kill-ringに保存されたURLまたはファイルパスの画像をダウンロードして挿入する。 Diredでファイルパスを取得するには、 0 w コマンドを使用する。\norg-download-screenshot このコマンドを実行すると、スクリーンショットを取得するためのアプリケーションが起動し、 OSのカーソルがスクリーンショットの範囲選択に切り替わる。 取得したスクリーンショットは、指定した場所に挿入される。 デフォルトではスクリーンショットのアプリケーションが gnome-screenshot になっており MacOS用に設定を変更する必要があった。\n(setq org-download-screenshot-method \"screencapture -i %s\") ","ドラッグ-and-ドロップ#ドラッグ\u0026amp;ドロップ":""},"title":"org-download"},"/docs/emacs/rustic-mode-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/":{"data":{"":" Command Key Description rustic-compile C-c C-c C-u cargo build rustic-cargo-doc C-c C-c d cargo doc rustic-cargo-check C-c C-c C-k cargo check rustic-cargo-run C-c C-n, C-c C-c C-r cargo run rustic-cargo-add C-c C-c a cargo add "},"title":"rustic-mode コマンド"},"/docs/js/emacs-setup/":{"data":{"":"","参考#参考":"新しいinit.elに切り替えてから、しばらくtypescriptを触る機会が無かったが 久し振りにソースを開いたらLSPが動かなくて困った。以前は web-mode をlsp-modeで起動してたはずなのだけど 新しい環境だと動かなくなってた。Emacsのバージョンが上ったせい?\nとりあえず、Eglotで typescript-language-server を起動するように設定し難を逃れる。\n参考 Setting Up TypeScript and Eslint With Eglot Modern Emacs Typescript Web (React) Config with lsp-mode, treesitter, tailwind, TSX \u0026 more "},"title":"Emacs Setup"},"/docs/ruby/ruby-atcoderab%E5%95%8F%E9%A1%8C%E7%94%A8%E3%83%A1%E3%83%A2/":{"data":{"":"","0パディングはrjust#0パディングはrjust":"","substringは-x-dot-dot-y#substringは[x..y]":"","一時変数の省略にはthenを使う#一時変数の省略にはthenを使う":"","文字列はchompする#文字列はchompする":"","文字列内の変数展開#文字列内の変数展開":"","連続した範囲--range#連続した範囲(Range)":"普段Rubyを全然書かないので、少しAtCoderから離れると構文とか入出力とか全部忘れてしまう。 忘れたときに見返す為のメモとしてここに記録しておく。\n文字列内の変数展開 ダブルクォート内で #{} 。シングルクォートだと展開できない。\nname = \"Ruby\" puts \"Hello, #{name}!\" # =\u003e \"Hello, Ruby!\" 文字列はchompする しないと改行文字が含まれる。\ns = gets.chomp 一時変数の省略にはthenを使う puts gets.chomp.then{ |s| s == 'no_no' || s \u003e '999' ? 'No' : 'Yes' } 0パディングはrjust num = 42 puts num.to_s.rjust(5, '0') # =\u003e \"00042\" substringは[x..y] i = gets.chomp[3..].to_i 連続した範囲(Range) (x..y) もしくは (x...y) 。ドット3つは終端を含まない(半開範囲)\nputs (1..349).reject{ |x| x == 316 } "},"title":"Ruby AtCoder(A,B問題用メモ)"},"/docs/rust/%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/":{"data":{"":"","generic-ifetimes-in-functions#Generic ifetimes in Functions":"","lifetime-annotation-syntax#Lifetime Annotation Syntax":"","lifetime-annotations-in-function-signatures#Lifetime Annotations in Function Signatures":"","lifetime-annotations-in-method-definitions#Lifetime Annotations in Method Definitions":"Validating References with Lifetimes を読んだときのメモ。\nPreventing Dangling References with Lifetimes Rustのライフタイムの主目的は、 dangling reference を防ぐこと。\nfn main () { let r; { let x = 5; r = \u0026x; }// (1) println!(\"r: {r}\"); } The Borrow Checker 上記のコードはコンパイルできない。仮にコンパイル出来てしまうと、 (1) でxはdeallocateされるので、 (1) 以降でrを使った処理は、正常に動作しないことになる。これを防ぐために、Rustのコンパイラはborrow checkerという機能を使って コンパイル時に上記を不正なコードと判断してくれる。\nfn main() { let r; // ---------+-- 'a // | { // | let x = 5; // -+-- 'b | r = \u0026x; // | | } // -+ | // | println!(\"r: {r}\"); // | } borrow checker が上記のように 貸した側 と 借りた側 の変数のライフタイムの違いを検出し、 問題があればコンパイルエラーにしてくれる。\nGeneric ifetimes in Functions 以下はコンパイルが通らない。\nfn longest(x: \u0026str, y: \u0026str) -\u003e \u0026str { if x.len() \u003e y.len() { x } else { y } } 引数 x , y ライフタイムと、返却値のライフタイムの関係性が定まらないため。\nLifetime Annotation Syntax ライフタイムアノテーションの書き方:\n\u0026'a i32 参照の \u0026 の右に 'a を付ける。(aの部分はなんでも良いが慣習としてaが使われる)\nLifetime Annotations in Function Signatures fn longest\u003c'a\u003e(x: \u0026'a str, y: \u0026'a str) -\u003e \u0026'a str { if x.len() \u003e y.len() { x } else { y } } 上のようにライフタイムパラメータと付けることで、 「 x, y のうち、短い方のライフタイムと戻り値のライフタイムが同じになる」 とコンパイラに伝えることになる。 あくまでコンパイラにそう伝えるだけで、実際の変数のライフタイムが変わるわけではない。 この情報を参照して、 borrow checker はライフタイムの検査を行ってくれる。\n付与したライフタイムパラメータのライフタイムと、実際の戻り値のライフタイムと異なるエラーになる。\nfn main() { let string1 = String::from(\"long string is long\"); let result; { let string2 = String::from(\"xyz\"); result = longest(string1.as_str(), string2.as_str()); } println!(\"The longest string is {result}\"); } 人間であれば result が println! まで生きてることが見て分かるが、 コンパイラはあくまでライフタイムパラメータで示した取り決めに反してないかどうかしか分からない。\nThinking in Terms of Lifetimes fn longest\u003c'a\u003e(x: \u0026'a str, y: \u0026str) -\u003e \u0026'a str { x } 関数の戻り値が参照の場合、戻り値のライフタイムパラメータは、変数のいずれかのライフタイムパラメータと一致する必要がある。 上記のコードでyは、xと戻り値のライフタイムに関係が無いのでyにライフタイムパラメータを付ける必要はない。\n仮に、関数の戻り値が参照型で、その参照先が関数の引数のいずれかでないとすると、 その参照先は関数内で生成された値への参照となるが、これは dangling pointer になるのでコンパイルでエラーになる。\nfn longest\u003c'a\u003e(x: \u0026str, y: \u0026str) -\u003e \u0026'a str { let result = String::from(\"really long string\"); result.as_str() // コンパイルエラー } この場合の修正方法は、戻り値を String型に変更し、呼び出し側に所有権を持たせるようにする。\nつまるところ、Rustのライフタイムのシンタックスは、関数の引数のライフタイムと戻り値のライフタイムを紐付け、 コンパライが dangling pointer のチェックをするのに必要な情報を提供するためのもの、と言える。\nLifetime Elision ライフタイムアノテーションの付与がコードから明かな場合、省略することができる。 (昔のバージョンのRustでは全て手動で書く必要があった。今後コンパイラの推論の精度が上がると、手動で付与する場面がさらに減るかもしれない)\nコンパイラは、以下3つのルールを使って引数/戻り値のライフタイムを推測しようとする。 3つのルールのうち、最初の1つが関数の引数に適用されるもので、残りの2つは戻り値に適用されるものである。\nルール1: 全ての参照型の引数に別々のライフタイムパラメータを設定する ルール2: 引数のライフタイムパラメータが1つだけ設定されている場合、戻り値の全てに同じライフタイムパラメータが設定される ルール3: 引数が複数あるケースで、そのうちの1つ引数が \u0026self または \u0026mut self の場合(つまり、この関数が構造体のメソッドの場合)、 self のライフタイムが全ての戻り値のライフタイムとして設定される。 これらのルールを適用したうえでなお、引数/戻り値のライフタイムが定まらない場合、コンパイラエラーが発生する。 その場合、実装者がライフタイムアノーテーションを手動で付与する。\nfn first_word(s: \u0026str) -\u003e \u0026str { これにルール1と2を適用すると\nfn first_word\u003c'a\u003e(s: \u0026'a str) -\u003e \u0026'a str { となり。ライフタイムが確定する。したがって実装者はアノテーションを付与する必要はない。\nfn longest(x: \u0026str, y: \u0026str) -\u003e \u0026str { この場合、ルール1は適用できるが2と3は適用できない。\nfn longest\u003c'a, 'b\u003e(x: \u0026'a str, y: \u0026'b str) -\u003e \u0026str { これ状態がルール適用後となり、ライフタイムが確定しないので実装者がアノテーションを付与することになる。\nLifetime Annotations in Method Definitions ライフタイムがある構造体のメソッドの場合、 impl の後と構造体名の後にはライフタイムアノテーションが必要。\nimpl\u003c'a\u003e ImportantExcerpt\u003c'a\u003e { fn level(\u0026self) -\u003e i32 { 3 } } ルール1と3により、以下の announce_and_return_part メソッドの引数/戻り値のライフタイムは定まる。\nimpl\u003c'a\u003e ImportantExcerpt\u003c'a\u003e { fn announce_and_return_part(\u0026self, announcement: \u0026str) -\u003e \u0026str { println!(\"Attention please: {announcement}\"); self.part } } ","lifetime-elision#Lifetime Elision":"","preventing-dangling-references-with-lifetimes#Preventing Dangling References with Lifetimes":"","the-borrow-checker#The Borrow Checker":"","thinking-in-terms-of-lifetimes#Thinking in Terms of Lifetimes":""},"title":"ライフタイムについて"},"/docs/rust/expression%E5%BC%8F-and-statement%E6%96%87/":{"data":{"":"","expression--式#Expression(式)":"","statement--文#Statement(文)":"","セミコロン#セミコロン":"Expression(式) 値を生成する構文要素。 1 + 2 , if true {1} else {2} など。 (Rustのifはif文でなく、if式)\nStatement(文) 実行のみで値を変えさない構文要素。 let x = 5; など。\nセミコロン Expression(式)の最後にセミコロン(;)を付けると、その式はStatement(文)に変わり 値を返さなくなる。\nfn example() { let x = 5; // これは文。セミコロンが付いているため、値を返さない let y = { 3 + 2 }; // このブロック全体は式。最終行にセミコロンがないため5が返る let z = { 4; }; // セミコロンがあるため、zには()（ユニット）が代入される } "},"title":"Expression(式) and Statement(文)"},"/docs/tools/20241020093445-skk/":{"data":{"":"","mac--aquaskk#Mac (AquaSKK)":"Mac (AquaSKK) キーマップのカスタマイズ ユーザレベルの設定を ~/Library に配置\n$ cp /Library/Input\\ Methods/AquaSKK.app/Contents/Resources/keymap.conf ~/Library/Application\\ Support/AquaSKK 以下で ; をStickyKeyに\nStickyKey ;\nキーバインド C-q 半角カタカナ 全角！を打つには ~/Library/Application\\ Support/AquaSKK にsymbols.ruleを配置し AquaSKKの 環境設定 より追加したルールを選択する\n参考 AquaSKK の設定と使い方 "},"title":"SKK"}}