{"/blogs/hello-world/":{"data":{"":"+# Hello! World. + +こんにちは、世界。"},"title":"Hello World"},"/docs/anki/anki/":{"data":{"":"","setup#Setup":"","コマンド#コマンド":"Setup Anki まずは、Ankiをこちらからダウンロードしてインストールします。\nAnki Connect OrgファイルとAnkiを連携するためには、Ankiアプリに Anki Connectというプラグインをインストールする必要があります。 プラグインのインストール後、Ankiアプリを再起動してください。\nEmacs init.el に以下のコードを追加し、 anki-editor の設定を行いました。\n(leaf anki-editor :doc \"Minor mode for working with Anki decks and notes.\" :url \"https://github.com/louietan/anki-editor\" :ensure t :bind ((:anki-editor-mode-map (\"C-c a\" . anki-editor/body))) :pretty-hydra ((:title \"Anki Editor\" :color blue :quit-key \"q\" :foreign-keys warn :separator \"╌\") (\"Main\" ((\"p\" anki-editor-push-notes \"push notes\") (\"n\" anki-editor-push-new-notes \"push new notes\") (\"r\" anki-editor-retry-failed-notes \"retry failed notes\")) \"Editing\" ((\"i\" anki-editor-insert-default-note \"insert default\") (\"I\" anki-editor-insert-note \"insert note\") (\"d\" anki-editor-delete-notes \"delete note\") (\"c\" anki-editor-cloze-dwim \"cloze region or word\")) \"Export\" ((\"e\" anki-editor-export-subtree-to-html \"export subtree to HTML\") (\"h\" anki-editor-convert-region-to-html \"convert region to HTML\")) \"Other\" ((\"a\" anki-editor-api-check \"API check\") (\"s\" anki-editor-sync-collections \"sync collections\") (\"b\" anki-editor-gui-browse \"browse in GUI\") (\"g\" anki-editor-gui-add-cards \"add cards in GUI\"))))) READMEに載ってるコマンドをChatGPTに貼り付けて、pretty-hydra化した。\nコマンド anki-editor-insert-note ノート作成用コマンドです。以下の手順でノートが作成されます。\nデッキの選択 ノートタイプの選択 ノートの見出し(Note Heading)の入力 上記を入力すると、Anki用の PROPERTIES が付与されたOrgエントリが挿入されます。 挿入時点ではAnki側には送信されないため、送信は別途 anki-editor-push-notes コマンドで行います。\nなお、デッキはOrgファイルのプロパティや、親のサブツリーに設定がある場合は継承されるので、 コマンド実行時に入力する必要はありません。 また、anki-editorは、READMEに記載されているようにBack/Front用のサブツリーを省略した簡易的な書き方もサポートしています。 この形式を使用したい場合は、Note Headingを空欄にしておくと自動でサブツリーが作成されません。\nanki-editor-insert-default-note このノート作成コマンドは、Orgファイルのプロパティや親のサブツリーで設定した ANKI_DEFAULT_NOTE_TYPE を自動で読み込み、 ノートタイプを決定します。 私の運用では、1つのOrgファイルにつき1つのデッキとノートタイプのみを使用しているため、 Orgファイルのプロパティに ANKI_DECK と ANKI_DEFAULT_NOTE_TYPE を設定し、 このコマンドを使ってノートを追加するようにしています。\nanki-editor-push-notes 作成したノートをAnkiアプリに送信するためのコマンドです。 Ankiアプリが起動中で、かつAnki Connect設定済みである必要があります。\n送信後、エントリにANKI_NOTE_IDが付与され、次回以降の更新が可能になります。\n:PROPERTIES: :ANKI_NOTE_TYPE: Basic :ANKI_DECK: English :ANKI_NOTE_ID: 1729834505855 :END: anki-editor-push-new-notes まだAnkiに送信していないノートを送信します。\nanki-editor-cloze-dwim 択したリージョンまたはカーソル下の単語をAnkiの穴埋め問題形式に変換します。 穴埋め問題についてはこちらが分かりやすいです。\nanki-editor-gui-browse カーソル位置のノートをAnkiアプリで確認できます。"},"title":"Anki"},"/docs/emacs/20241020210719-tab_bar_mode/":{"data":{"":"","tab-bar-mode#tab-bar-mode":"tab-bar-mode ずっとバッファをtabに表示するものと思って使ってこなかった (それは多分 tab-line-mode)。 tab-bar-mode はウィンドウ構成を1タブで管理する。便利。\n使いそうなコマンド:\nC-x t 2: 新規タブ作成 C-x t 0: 現在タブ削除 C-x t o: タブ移動 C-x t RET: タブ選択 tab-bar-history-mode を有効にすると、タブ一覧の左に\u003c \u003eが表示されるようになる。 これをポチポチすると、そのタブのウィンドウ構成を遡ることができる。 tab-bar-historyのコマンドもあるけど滅多に使わなそうなので、当面マウス操作で良いか。\ntab-bar-mode を使うと org-agenda-window-setup で other-tab のオプションが使えるようになる\n(setq org-agenda-window-setup 'other-tab) org-agendaを開くと、自動で新規タブが作られ、そのタブでアジェンダが表示される。 アジェンダを閉じるとタブも閉じられる。 既存のウィンドウ構成を崩さずにフレームを目一杯使ってアジェンダを表示できて嬉しい\n参考 tab-bar-modeを探検する "},"title":"tab-bar-mode"},"/docs/emacs/20241021104652-smartparens/":{"data":{"":"","smartparens#smartparens":"smartparens s-c にhydraを用意した。\n(leaf *hydra-cursor :doc \"Move cursor effectively\" :bind (\"s-c\" . *hydra-cursor/body) :after smartparens :pretty-hydra ((:title \"➤ Smart Cursor\" :color blue :quit-key \"q\" :foreign-keys warn :separator \"╌\") (\"Sexp\" ((\"a\" sp-beginning-of-sexp \"Begin\" :exit nil) (\"e\" sp-end-of-sexp \"End\" :exit nil) (\"d\" sp-down-sexp \"Down\" :exit nil) (\"u\" sp-up-sexp \"Up\" :exit nil) (\"D\" sp-backward-down-sexp \"Down backward\" :exit nil) (\"U\" sp-backward-up-sexp \"Up backward\" :exit nil) (\"n\" sp-next-sexp \"Next\" :exit nil) (\"p\" sp-previous-sexp \"Previous\" :exit nil) (\"F\" sp-forward-sexp \"Forward\" :exit nil) (\"B\" sp-backward-sexp \"Backward\" :exit nil)) \"Symbol\" ((\"f\" sp-forward-symbol \"Forward\" :exit nil) (\"b\" sp-backward-symbol \"Backward\" :exit nil)) \"Wrap\" ((\"(\" wrap-with-parens \"() parens\" :exit nil) (\"[\" wrap-with-brackets \"[] brackets\" :exit nil) (\"{\" wrap-with-braces \"{} braces\" :exit nil) (\"'\" wrap-with-single-quotes \"'' single quotes\" :exit nil) (\"\\\"\" wrap-with-double-quotes \"\\\"\\\" double quotes\" :exit nil)) \"Unwrap\" ((\",\" sp-backward-unwrap-sexp \"Backward\" :exit nil) (\"k\" sp-kill-sexp \"Kill\" :exit nil) (\".\" sp-forward-unwrap-sexp \"Forward\" :exit nil)) \"Expand\" ((\"+\" sp-forward-slurp-sexp \"Expand\" :exit nil) (\"-\" sp-forward-barf-sexp \"Shrink\" :exit nil))))) 正直、カーソルの移動系はnativeとの違いが分からないのが多かった。 以下は見たことがない動きなので使えるかも。\nsp-next-sexp ( C-M-n にもバインド) sp-previous-sexp ( =C-M-p にもバインド) wrap-xxxはこちらの defcustom を使わせて頂いた。 C-SPC で選択した範囲を囲うのと併せて、使う機会は多そう。\n参考 Emacsの括弧機能を超絶強化するsmartparensとrainbow-delimiters "},"title":"smartparens"},"/docs/emacs/20241021144801-lsp_bridge/":{"data":{"":"","lsp-breidge-refのカスタマイズ#lsp-breidge-refのカスタマイズ":"lsp-breidge-refのカスタマイズ lsp-bridgeは C-c C-r で参照一覧をlsp-briedge-ref ウィンドウで表示するが、 一覧を閉じるタイミングで、これまで参照から開いてたたバッファも全て消えてしまう。\nこれは、 lsp-bridge-ref-kill-temp-buffer-p と lsp-bridge-ref-open-file-in-request-window の両方を nilにすることで解決する。 以下でlsp-bridge-refに関するcustomize変数をまとめる。\n設定名 初期値 説明 lsp-bridge-ref-delete-other-windows t refウィンドウを開くタイミングで、refを開始したウィンドウ以外のウィンドウを閉じるか lsp-bridge-ref-open-file-in-request-window nil refで参照先を移動する際に、refを開始したウィンドウをそのまま使用するか lsp-bridge-ref-kill-temp-buffer-p t refウィンドウから開いたバッファを保持せずに閉じるか lsp-bridge-ref-open-file-in-request-window をtにすると lsp-bridge-ref-kill-temp-buffer-p が無効になる気がする"},"title":"lsp-bridge"},"/docs/emacs/20241022120540-gpg_gnupg/":{"data":{"":"","秘匿情報をgpgファイルから取得する#秘匿情報をgpgファイルから取得する":"秘匿情報をgpgファイルから取得する init.el に直接書きたくない秘匿情報の扱いに困ることがたまにあって、 gpgファイルについて調べた。よく分かってないこともあるが、以下で自分に必要な最低限のことはできる。 (※対象環境はMacOS)\nインストール pgp と pinentry-mac をインストール\nbrew install gnupg brew install pinentry-mac pinentry-macはパスフレーズを入力するためのUIで、 PGPファイルをパスフレーズで暗号化するときに使用する。\nインストールしたら、 .bashrc で以下の環境変数を設定し、\nexport GPG_TTY=$(tty) さらに、pgp-agent.confでpinentry-programを指定する。\necho \"pinentry-program /opt/homebrew/bin/pinentry-mac\" \u003e\u003e ~/.gnupg/gpg-agent.conf gpgをインストールしただけだと、パスフレーズ入力のタイミングでエラーになるので注意\nError while encrypting with “/opt/homebrew/bin/gpg”:\ngpg: problem with the agent: Inappropriate ioctl for device gpg: error creating passphrase: Operation cancelled gpg: symmetric encryption of ‘[stdin]’ failed: Operation cancelled\nPGPファイルの作成 ~/.authinfo.gpg に以下の形式でgpgファイルを作成する。\nmachine gcal-client-id login your-client-id password 123456789-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com machine gcal-client-secret login your-client-secret password ABCDEF-GhIjKlMnOpQrStUvWxYz machine はサービスや識別子を指定する。 elisp から :host で指定する login は本来ユーザー名らしいけど、今回は使わない password の後に実際の値（クライアントIDやクライアントシークレット）を記述する。 elisp elispからは auth-source パッケージの auth-source-pick-first-password を使って設定した password の値を取得できる\n(setq auth-sources '(\"~/.authinfo.gpg\")) (setq gcal-client-id (auth-source-pick-first-password :host \"gcal-client-id\")) (setq gcal-client-secret (auth-source-pick-first-password :host \"gcal-client-secret\")) あとで読みたい Keeping Secrets in Emacs with GnuPG and Auth Sources "},"title":"gpg (GnuPG)"},"/docs/emacs/copilot/":{"data":{"":" s-p でcopilotモード起動 Tab で補完の選択 C-c Tab で次の補完 とした。copilot-chatも導入して、特に問題なく動いているが、現時点で使用する場面がはっきりしていない。\n(leaf copilot :el-get (copilot :type github :pkgname \"zerolfx/copilot.el\") :bind (\"s-p\" . copilot-mode) :config (leaf editorconfig :ensure t) (leaf s :ensure t) (leaf dash :ensure t) (defun my/copilot-tab () (interactive) (or (copilot-accept-completion) (indent-for-tab-command))) (with-eval-after-load 'copilot (define-key copilot-mode-map (kbd \"\u003ctab\u003e\") #'my/copilot-tab) (define-key copilot-mode-map (kbd \"C-c \u003ctab\u003e\") #'copilot-next-completion))) (leaf copilot-chat :el-get (copilot-chat :type github :pkgname \"chep/copilot-chat.el\") :after (request shell-maker) :custom (copilot-chat-frontend 'shell-maker) :config (require 'copilot-chat-shell-maker) (push '(shell-maker . copilot-chat-shell-maker-init) copilot-chat-frontend-list) (copilot-chat-shell-maker-init)) "},"title":"Copilot"},"/docs/emacs/lsp-dart/":{"data":{"":"久し振りにFlutterプロジェクトを開いたら、動かなくなってて困った。 前回からEmacsの設定を大幅な見直しがあったので、それが要因だと思うけど、結局根本的な原因はよく分からず…\n以前はlsp-dartを入れるだけで大体動いたと記憶してるが、今回はシンタックスハイライトが効かなかったり、LSPが起動しなくなったり嵌ってしまった。\n(leaf dart-mode :ensure t :init (require 'tree-sitter) (require 'treesit) (add-hook 'dart-mode-hook #'tree-sitter-hl-mode) :mode ((\"\\\\.dart\\\\'\" . dart-mode))) (leaf lsp-dart :ensure t :config (defun wal/find-dart-flutter-sdk-dir () \"Find the Dart Flutter SDK directory.\" (when-let* ((flutter-bin (executable-find \"flutter\")) (sdk-dir (string-trim (shell-command-to-string \"flutter sdk-path\")))) sdk-dir)) (setq lsp-dart-test-tree-on-run nil) (when (string= system-type \"gnu/linux\") (setq lsp-dart-flutter-sdk-dir (wal/find-dart-flutter-sdk-dir))) (when (string= system-type \"darwin\") (setq lsp-dart-flutter-sdk-dir \"~/flutter\")) (when (string= system-type \"windows-nt\") (setq lsp-dart-flutter-sdk-dir \"C:/Users/wtnbjn/scoop/apps/flutter/current\")) :custom (lsp-dart-test-tree-on-run . nil) :hook (dart-mode-hook . lsp)) 以下のとおり、 dart-mode でtree-sitter-hl-modeをフックするようにした。\n:init (require 'tree-sitter) (require 'treesit) (add-hook 'dart-mode-hook #'tree-sitter-hl-mode) :mode ((\"\\\\.dart\\\\'\" . dart-mode))) こんなの前までやらなくてもハイライトされてたと思うんだけど、謎。\ndar-ts-mode を用意してくれてる方がいて、セットアップすると ts-mode になるのでハイライトされるが、 今度はlsp-dartでlspが起動しなくなってしまう。 多分、lsp-dartがまだdart-mode前提になってる。"},"title":"lsp-dart"},"/docs/tools/20241020093445-skk/":{"data":{"":"","mac--aquaskk#Mac (AquaSKK)":"Mac (AquaSKK) キーマップのカスタマイズ ユーザレベルの設定を ~/Library に配置\n$ cp /Library/Input\\ Methods/AquaSKK.app/Contents/Resources/keymap.conf ~/Library/Application\\ Support/AquaSKK 以下で ; をStickyKeyに\nStickyKey ;\nキーバインド C-q 半角カタカナ 全角！を打つには ~/Library/Application\\ Support/AquaSKK にsymbols.ruleを配置し AquaSKKの 環境設定 より追加したルールを選択する\n参考 AquaSKK の設定と使い方 "},"title":"SKK"}}